classdef dGeneric < handle  % Calls by reference
    % dGeneric Generic random variable class.

% Copyright (C) 2018 Jeffrey Owen Miller
% 
%     This program is free software: you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation, either version 3 of the License, or
%     any later version.
% 
%     This program is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
%     GNU General Public License for more details.
% 
%     You should have received a copy of the GNU General Public License
%     along with this program (00License.txt). If not, see 
%     <http://www.gnu.org/licenses/>.
%
    
    properties(Hidden)  % Properties seen only by class methods
    end
    
    properties(SetAccess = private)    % These properties can only be set by the methods of this class.
    end
    
    properties(SetAccess = protected)  % These properties can only be set by the methods of this class and its descendants.
        DistType,         % 'c', 'd', or 'm' for continuous, discrete, or mixed.
        NDistParms,       % Number of free parameters for this distribution
        FamilyName,   % A generic name for this type of distribution, e.g., "Normal".
        StringName,       % A name for the particular distribution with its parameters, e.g., "Normal(0,1)".
        ParmNames,        % Array of strings with names of the distribution parameters, e.g. "'mu' & 'sigma''
        ParmTypes,        % Reserved for future use: One character for each parameter indicating its type: 'r'=real, 'i'=integer.
        Initialized,      % Keeps track of whether legal parameter values have been set.
        LowerBound,       % Effective minimum/maximum values for the distribution.
        UpperBound,
        NameBuilding,     % If true, generate FamilyName each time parameters are reset.  (setting to false speeds estimation)
        NValues,          % Number of discrete values in discrete or mixed distribution.
        
        % Splines can be used to approximate the PDF of the distribution as follows:
        % (There is an entirely parallel set of variables and functions for approximating the CDF.)
        HaveSplinePDFs   % Boolean indicating whether the spline approx has already been computed with the distribution's current parameters
        SplinePDFsXSpec  % This specification _determines_ the values of SplinePDFsXs.
        % If SplinePDFsXSpec is a vector, then it is used directly for SplinePDFsXs.
        % If SplinePDFsXSpec is a single number, then SplinePDFsXs is generated by dividing
        % the X range (LowerBound to UpperBound) into SplinePDFsXSpec equal steps.
        SplinePDFsXs     % The X values at which the PDF is approximated.
        SplinePDFs       % The PDF values for these Xs (computed prior to the approximation).
        PDFSplineInfo    % A record holding MATLAB's description of the spline.
        
        % Analogous variables controlling the spline approximation of the CDF & InverseCDF:
        HaveSplineCDFs, SplineCDFsXSpec, SplineCDFsXs, SplineCDFs, CDFSplineInfo
        HaveSplineInvCDFs, SplineInvCDFsXSpec, SplineInvCDFsPs, SplineInvCDFs, InvCDFSplineInfo
        
        % Variables for a separate set of CDF computation methods that use stored CDF values.
        % The idea is to speed up repeated CDF computations by reducing the area over which
        % integration is done.  A set of StoredXs is constructed, and CDFs for these Xs are
        % computed by numerical integration as usual.  Then, to get the CDF for Y, integration
        % is done only for the segment of the PDF from the next-smaller-X to Y.
        % NWJEFF: I think this is only used for continuous; discrete does the same thing separately
        UseStoredCDFs   % Boolean to indicate whether stored CDFs are to be computed
        HaveStoredCDFs  % Boolean to indicate whether stored CDFs values have computed with latest parameter values
        StoredXs        % X values for which StoreCDFs stores the CDF values
        StoredCDFs      % CDF value for each of the StoredXs
        DefaultNBinsOfX % Number of Xs at which to store CDFs
        
        NBNStored, NBStored  % Used with PushAndStopNameBuilding
    end
    
    properties(SetAccess = public)  % These properties can be changed without restriction
        XNearlyZero, XNearlyOne, CDFNearlyZero, CDFNearlyOne, PDFNearlyZero
        SearchOptions     % A MATLAB optimset used in parameter searching.
        UseSplinePDF      % Boolean indicating whether the PDF is to be approximated with splines
        UseSplineCDF      % Boolean indicating whether the CDF is to be approximated with splines
        UseSplineInvCDF   % Boolean indicating whether the Inverse CDF is to be approximated with splines
        DefaultParmCodes  % One character for each parameter indicating whether it is 'f'=fixed or not during parameter estimation.
        MLSEh             % A small delta used in computing the Fisher information (FI).
        Smallrcond        % The minimum rcond of the Fisher information matrix; below this value, print a warning.
        SkipImpossibleWarn % Flag to skip warning about computing likelihood of impossible data value.
    end
    
    methods(Abstract)
        
        thispdf=PDF(obj,X)  % Separate versions for continuous vs discrete RVs.
        thiscdf=CDF(obj,X)
        thiscdf=InverseCDF(obj,X)
        Reals=ParmsToReals(obj,Parms,ParmCodes)
        Parms=RealsToParms(obj,Reals,ParmCodes)
        []=ResetParms(obj,newparmvalues)
        x = XsToPlot(obj)
        
    end  % Abstract methods
    
    methods
        
        function obj=dGeneric(FamName)   % Constructor
            obj.FamilyName = FamName;
            obj.ParmNames = properties(obj.FamilyName);
            obj.Initialized = false;
            obj.NameBuilding = true;
            obj.XNearlyZero = 0.1e-10;
            obj.PDFNearlyZero = 0.1e-10;
            obj.CDFNearlyZero = 0.1e-10;
            obj.XNearlyOne = 1 - obj.XNearlyZero;
            obj.CDFNearlyOne = 1 - obj.CDFNearlyZero;
            obj.SearchOptions = optimset('fminsearch');
            % obj.SearchOptions.Display = 'iter';
            obj.SearchOptions.MaxFunEvals = 10000;
            obj.SearchOptions.MaxIter = 10000;
            obj.SearchOptions.TolFun = 1e-14;
            obj.SearchOptions.TolX = 1e-14;
            obj.UseSplinePDF = false;
            obj.HaveSplinePDFs = false;
            obj.SplinePDFsXSpec = 300;
            obj.UseSplineCDF = false;
            obj.HaveSplineCDFs = false;
            obj.SplineCDFsXSpec = 300;
            obj.UseSplineInvCDF = false;
            obj.HaveSplineInvCDFs = false;
            obj.SplineInvCDFsXSpec = 300;
            obj.MLSEh = 0.0001;
            obj.Smallrcond = 1e-6;
            obj.NBNStored = 0;
            obj.NBStored = zeros(10,1);
            obj.SkipImpossibleWarn = false;
        end
        
        % **************** Some house-keeping functions:
        
        function []=ClearBeforeResetParms(obj)
            switch obj.DistType
                case 'c'
                    obj.ClearBeforeResetParmsC;
                case 'd'
                    obj.ClearBeforeResetParmsD;
            end
        end
        
        function [] = ResetSomeParms(obj, varargin)
            % Arguments are (Parm,NewVal) pairs.
            CurrentParms = ParmValues(obj);
            NPairs = (nargin-1)/2;  % Remember nargin includes "obj"
            for iPair=1:NPairs
                Parm = varargin{2*iPair-1};
                NewVal = varargin{2*iPair};
                if ischar(Parm)
                    ThisParmNo = strcmpi(Parm,obj.ParmNames);
                else
                    ThisParmNo = Parm;
                end
                CurrentParms(ThisParmNo) = NewVal;
            end
            ResetParms(obj,CurrentParms);
        end
 
% This function is unnecessary. Only public fields can be reset, and
% they can be reset directly by assignment statements.       
%        function [] = ResetFields(obj, varargin)
%            % Arguments are (sField,NewVal) pairs.
%            NPairs = (nargin-1)/2;  % Remember nargin includes "obj"
%            for iPair=1:NPairs
%                sField = varargin{2*iPair-1};
%                NewVal = varargin{2*iPair};
%                obj.(sField) = NewVal;
%            end
%            % ResetParms(obj,CurrentParms);
%        end
        
        function RandomParms(obj)
            % Set the distribution to random parameter values.
            if obj.NDistParms==0
                return;
            end
            RealParms=10*rand(obj.NDistParms,1) - 5;
            LegalParms = RealsToParms(obj,RealParms);
            ResetParms(obj,LegalParms);
        end
        
        function parmvals = ParmValues(obj,varargin)
            % Return values of all parameters if no second parameter, or else
            % Return values of parameters whose numbers are listed in second parameter.
            if nargin == 1
                WantList = 1:obj.NDistParms;
            else
                WantList = varargin{1};
            end
            parmvals = zeros(1,numel(WantList));
            for iParm = 1:numel(WantList)
                sParm = obj.ParmNames{WantList(iParm)};
                parmvals(iParm) = obj.(sParm);
            end
        end
        
        function []=BuildMyName(obj)
            s = obj.FamilyName;
            parms = obj.ParmValues;
            if obj.NDistParms > 0
                s = [s '('];
                for iParm = 1:obj.NDistParms
                    if iParm > 1
                        s = [s ','];%#ok<AGROW>
                    end
                    s = [s num2str(parms(iParm))];%#ok<AGROW>
                end
                s = [s ')'];
            end
            obj.StringName = s;
        end
        
        function PushAndStopNameBuilding(obj)
            % This is used to temporarily turn off distribution NameBuilding, which speeds things up.
            obj.NBNStored = obj.NBNStored + 1;
            obj.NBStored(obj.NBNStored) = obj.NameBuilding;
            obj.NameBuilding = false;
        end
        
        function PopNameBuilding(obj)
            obj.NameBuilding = obj.NBStored(obj.NBNStored);
            obj.NBNStored = obj.NBNStored - 1;
        end
        
        function thisval=FnAfterReset(obj,ParmToChange,NewParmVals,sFn,varargin)
            % Function to reset parameters and then compute single-output function of arguments in varargin
            % Returns obj to its original parameter values when done.
            obj.PushAndStopNameBuilding;
            HoldParms = ParmValues(obj);
            thisval = zeros(size(NewParmVals));
            for iVal=1:numel(NewParmVals)
                ResetSomeParms(obj,ParmToChange,NewParmVals(iVal));
                thisval(iVal) = obj.(sFn)(varargin{:});
            end
            obj.PopNameBuilding;
            ResetParms(obj,HoldParms);
        end
        
        function Iout=VerifyIntegerGE(obj,GE,Iin)
            sGE = num2str(GE);
            if Iin < GE
                Iout = GE;
                if (obj.NameBuilding)
                    warning([obj.FamilyName ' parameter must be an integer >= ' sGE '; set to ' sGE '.']);
                end
            elseif ~iswholenumber(Iin)
                Iout = round(Iin);
                if (obj.NameBuilding)
                    warning([obj.FamilyName ' parameter must be an integer >= ' sGE '; ' sprintf('%f',Iin) ' rounded to ' num2str(Iout) '.']);
                end
            else
                Iout = round(Iin);
            end
        end
        
        function Iout=VerifyIntegerInRange(obj,Min,Max,Iin)
            sMin = num2str(Min);
            sMax = num2str(Max);
            if Iin < Min
                Iout = Min;
                if (obj.NameBuilding)
                    warning([obj.FamilyName ' parameter must be an integer >= ' sMin '; set to ' sMin '.']);
                end
            elseif Iin > Max
                Iout = Max;
                if (obj.NameBuilding)
                    warning([obj.FamilyName ' parameter must be an integer <= ' sMax '; set to ' sMax '.']);
                end
            elseif ~iswholenumber(Iin)
                Iout = round(Iin);
                if (obj.NameBuilding)
                    warning([obj.FamilyName ' parameter must be an integer between ' sMin ' and ' sMax ; rounded to ' Iout '.']);
                end
            else
                Iout = round(Iin);
            end
        end
        
        function thiserrorstring=UninitializedError(obj)
            % Return an error string with the distribution name
            thiserrorstring=['Attempted to compute with ' obj.FamilyName ' distribution before initializing it.'];
        end
        
        function thiserrorstring=IllegalParm(obj)
            % Return an error string with the distribution name
            thiserrorstring=['Attempted to access a non-existent parameter of ' obj.FamilyName ' distribution.'];
        end
        
        function thiserrorstring=GenericError(obj,S)
            % Return an error string with the distribution name
            thiserrorstring=['Error in ' obj.FamilyName ': ' S];
        end
        
        % **************** Basic functions for all random variables:

        function [thispdf, InBounds, Done] = MaybeSplinePDF(obj,X)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            thispdf=zeros(size(X));
            InBounds = (X>=obj.LowerBound) & (X<=obj.UpperBound);
            if obj.UseSplinePDF
                thispdf(InBounds) = obj.GetSplinePDF(X(InBounds));
                Done = true;
            else
                Done = false;
            end
        end
        
        function [thiscdf, InBounds, Done] = MaybeSplineCDF(obj,X)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            thiscdf=zeros(size(X));
            thiscdf(X>obj.UpperBound) = 1;
            InBounds = (X>=obj.LowerBound) & (X<=obj.UpperBound);
            if obj.UseSplineCDF
                thiscdf(InBounds) = obj.GetSplineCDF(X(InBounds));
                Done = true;
            else
                Done = false;
            end
        end
        
        function thisval=RawMoment(obj,I)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            thisval = IntegralXToNxPDF(obj,obj.LowerBound,obj.UpperBound,I);
        end
        
        function thisval=CenMoment(obj,I)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            Mu = Mean(obj);
            thisval = IntegralX_CToNxPDF(obj,obj.LowerBound,obj.UpperBound,Mu,I);
        end
        
        function thisval=CenMomentFromRawMoment(obj,I)
           % E( (X-u)^I ) == \sum_{k=0}^I (k) * (-1)^k * E(X^(I-k)) * u^k *)
           Mu = obj.Mean;
           thisval = 0;
           Sign = -1;
           for k=0:I
              Sign = -Sign;
              thisval = thisval + Sign * nchoosek(I,k) * obj.RawMoment(I-k) * Mu^k;
           end;
        end

        function thisval=Median(obj)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            thisval=InverseCDF(obj,0.5);
        end
        
        function thisval=Mean(obj)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            thisval = RawMoment(obj,1);
        end
        
        function thisval=Variance(obj)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            thisval = CenMoment(obj,2);
            % Alternative computation: RawMoment(2) - (Mean)^2
        end
        
        function thisval=SD(obj)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            thisval = sqrt(Variance(obj));
        end
        
        function thisval=VarianceGivenMu(obj,passMu)
            % This will often be faster in cases where you already have the mean.
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            thisval = RawMoment(obj,2) - passMu^2;
        end
        
        function thisval=SDGivenMu(obj,passMu)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            thisval = sqrt(VarianceGivenMu(obj,passMu));
        end
        
        function thisval=CV(obj)
            % Coefficient of variation = SD / Mean
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            try
                thisval=SD(obj)/Mean(obj);
            catch CVErr
                thisval=NaN;
            end
        end
        
        function thisval=RawSkewness(obj)
            % 3rd central moment^(1/3)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            % thisval = CenMoment(obj,3)^(1/3);
            CenMom3 = CenMoment(obj,3);
            if CenMom3 >= 0
                thisval = CenMom3^(1/3);
            else
                thisval = -(-CenMom3)^(1/3);
            end
            % NwJeff: Could do more by checking whether certain functions are known.
        end
        
        function thisval=RelSkewness(obj)  % 3rd central moment / sd^3
            % E[(X-u)^3] / SD^3 From Winer, Brown, & Michels, 1991, p. 849:
            % RelSkewness = CenMom3 / CenMom2 / Sqrt(CenMom2)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            XSD = SD(obj);
            XSkew = RawSkewness(obj);
            try
                thisval = XSkew * XSkew^2 / XSD^3;
            catch RelSkewErr
                thisval = NaN;
            end
        end
        
        function thisval=Kurtosis(obj)
            % From Winer, Brown, & Michels, 1991, p. 849:
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            try
                thisval=CenMoment(obj,4) / Variance(obj)^2;
            catch KurtosisError
                KurtosisError;
                thisval=NaN;
            end
        end
        
        function thisval=Hazard(obj,X)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            HiCDF = 1 - CDF(obj,X);
            thisval = PDF(obj,X) ./ HiCDF;
        end
        
        function thisval=MGF(obj,PassTheta)
            % Returns sum or integral from LowerBound to UpperBound of exp(Theta*X) * PDF.
            % Note that the function value for Theta == 0 should be one and this property
            % can be used as a check of the accuracy of computing PDF.
            % Also note PassTheta should be close to zero to avoid numerical problems
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            try
                thisval=MGFrng(obj,PassTheta,obj.LowerBound,obj.UpperBound);
            catch
                thisval=NaN;
            end
        end
        
        function thisval=LnLikelihood(obj, Observations)
            % Computes LnLikelihood of a set of observations, e.g. for parameter search.
            % The case of an observation with PDF=0 is handled by setting the PDF to
            % a small value that decreases with Distance outside the Upperbound or Lowerbound.
            % This imposes a penalty for observations outside the range based on how far outside
            % the range they are, thus helping to push parameter search routines in the right direction.
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            Like = PDF(obj,Observations);
            ZeroPos = find(Like==0);
            if numel(ZeroPos) && ~(obj.SkipImpossibleWarn > 0)
                warning([obj.FamilyName ' checking likelihood of impossible data values.']);
            end
            for I = 1:length(ZeroPos)
                J = ZeroPos(I);
                X = Observations(J);
                % Penalize here if X out of range.
                if (X < obj.LowerBound)
                    Distance = 10*(obj.LowerBound - X) + 1;  % Distance should never be less than 1.
                elseif (X > obj.UpperBound)
                    Distance = 10*(X - obj.UpperBound) + 1;  % Distance should never be less than 1.
                else
                    Distance = 1;
                end
                Like(J) = 10^(-20) / Distance;
                if (Like(J) < realmin)
                    Like(J) = realmin;
                end
            end
            % Like
            LnLike = log(Like);
            thisval = sum(LnLike);
        end
        
        function [] = StoreCDFs(obj,NBinsOrListOfX)
            % Parameter is either the number of bins to consider or else a list of the
            %  X values at which to compute CDFs.
            if numel(NBinsOrListOfX) == 1
                StepSize = (obj.UpperBound - obj.LowerBound) / NBinsOrListOfX;
                obj.StoredXs = obj.LowerBound+StepSize:StepSize:obj.UpperBound-StepSize;
            else
                obj.StoredXs = NBinsOrListOfX;
            end
            obj.StoredCDFs = obj.StoredXs;  % Just copying the size
            if obj.DistType==Continuous
                obj.StoredCDFs(1) = integral(@(x) PDF(obj,x),obj.LowerBound,obj.StoredXs(1),'AbsTol',obj.IntegralPDFAbsTol,'RelTol',obj.IntegralPDFRelTol);
                for iel=2:numel(obj.StoredXs)
                    obj.StoredCDFs(iel) =  integral(@(x) PDF(obj,x),obj.StoredXs(iel-1),obj.StoredXs(iel),'AbsTol',obj.IntegralPDFAbsTol,'RelTol',obj.IntegralPDFRelTol)
                end
                obj.StoredCDFs = cumsum(obj.StoredCDFs);
                obj.StoredCDFs(end) = 1;
            else
                obj.StoredCDFs = obj.CDF(obj.StoredXs);
            end
            obj.UseStoredCDFs = true;
            obj.HaveStoredCDFs = true;
        end
        
        function thisval=YNProbitLnLikelihood(obj,Constants, NTrials, NGreater)
            % Greater is the number of times that the Constant value is greater
            % than the value in the distribution. NGreater should increase with C.
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            NObservations = numel(Constants);
            % Probit.tex explains why no binomial coefficient is needed.
            thisval = 0;
            for I = 1:NObservations
                p = CDF(obj,Constants(I));
                omp = 1 - p;
                p = log(p) * NGreater(I);
                omp = log(omp) * (NTrials(I) - NGreater(I));
                thisval = p + omp + thisval;
            end
        end
        
        function thisval=YNProbitChiSq(obj, Constants, NTrials, NGreater)
            % Greater is the number of times that the Constant value is greater
            % than the value in the distribution. NGreater should increase with C.
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            NObservations = numel(Constants);
            thisval = 0;
            for I = 1:NObservations
                p = CDF(obj,Constants(I));
                omp = 1 - p;
                Obsp = NGreater(I) / NTrials(I);
                % Obsp = 1 - Obsp; % This would be appropriate if NGreater would decrease with C.
                thisval = NTrials(I) * (p-Obsp)^2 / (p * omp) + thisval;
            end
        end
        
        function thisval=mAFCProbitLnLikelihood(obj, PassM, Constants, NTrials, NCorrect)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            NObservations = numel(Constants);
            % Probit.tex explains why no binomial coefficient is needed.
            thisval = 0;
            GuessProb = 1 / PassM;
            NError = NTrials - NCorrect;
            for I = 1:NObservations  % NWJEFF: Vectorize this and other probit est
                p = CDF(obj,Constants(I));
                % p = GuessProb + (1 - GuessProb) * p;
                omp = 1 - p;
                p = p + omp*GuessProb;  % Seems more intuitive
                p = log(p) * NCorrect(I);
                omp = log(omp) * NError(I);
                thisval = p + omp + thisval;
            end
        end
        
        function thisval=mAFCProbitChiSq(obj, PassM, Constants, NTrials, NCorrect)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            NObservations = numel(Constants);
            thisval = 0;
            GuessProb = 1 / PassM;
            for I = 1:NObservations
                p = CDF(obj,Constants(I));
                p = GuessProb + (1 - GuessProb) * p;
                omp = 1 - p;
                Obsp = NCorrect(I) / NTrials(I);
                thisval = NTrials(I) * (p-Obsp)^2 / (p * omp) + thisval;
            end
        end
        
        function thisval=GofFChiSq(obj, BinUpperBounds, BinProbs)
            % Note that the lowest bin is assumed to extend down to -infty
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            NBins = numel(BinUpperBounds);
            LastPredictedCDF = 0;
            SumObservedProp = 0;
            % B0 = BinBounds(0);
            % if DistType == Continuous Then LastPredictedCDF = CDF(B0)
            % else LastPredictedCDF = 0;
            Sum = 0;
            for I = 1:NBins
                NextBoundary = BinUpperBounds(I);
                NextObservedProp = BinProbs(I);
                SumObservedProp = SumObservedProp + NextObservedProp;
                NextPredictedCDF = CDF(obj,NextBoundary);
                PredictedPDF = NextPredictedCDF - LastPredictedCDF;
                LastPredictedCDF = NextPredictedCDF;
                Err = 0;
                if (PredictedPDF > 0)
                    Err = (NextObservedProp - PredictedPDF)^2 / PredictedPDF;
                elseif (NextObservedProp > 0)
                    Err = (1000*NextObservedProp)^2;
                end
                Sum = Sum + Err;
            end;
            if (SumObservedProp < 1)
                % Consider an implicit additional bin.
                NextObservedProp = 1 - SumObservedProp;
                PredictedPDF = 1 - LastPredictedCDF;
                if (PredictedPDF > 0)
                    Err = (NextObservedProp - PredictedPDF)^2 / PredictedPDF;
                elseif (NextObservedProp > 0)
                    Err = (1000*NextObservedProp)^2;
                end
                Sum = Sum + Err;
            end
            thisval = Sum;
        end
        
        
        function thisval=Minimum(obj)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            thisval=obj.LowerBound;
        end
        
        function thisval=Maximum(obj)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            thisval=obj.UpperBound;
        end
        
        function thisval=SIQR(obj)
            % Semi-interquartile range.
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            thisval = (InverseCDF(obj,0.75) - InverseCDF(obj,0.25) ) / 2;
        end
        
        function thisval=MMMSD(obj)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            ThisSD = SD(obj);
            if (ThisSD == 0)
                thisval = 0;
            else
                thisval = (Mean(obj) - Median(obj)) / ThisSD;
            end
        end
        
        function thisval=PctileSkew(obj,P)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            ThisMdn = Median(obj);
            ThisP = InverseCDF(obj,P);
            ThisOMP = InverseCDF(obj,1-P);
            if (ThisP == ThisOMP)
                thisval = 0;
            else
                thisval = (ThisP + ThisOMP - 2 * ThisMdn) / (ThisP - ThisOMP);
            end
        end
        
        function thisval=PDFBin(obj,X, BinWidth)
            % Probability between X and X+BinWidth
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            thisval=CDF(obj,X+BinWidth) - CDF(obj,X);
        end
        
        function thisval=OMCDF(obj,X)
            % One minus CDF(X)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            thisval = 1-CDF(obj,X);
        end
        
        function thisval=TwoTailProb(obj,X)
            % Twice the tail probability of X
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            ThisCDF = CDF(obj,X);
            if (ThisCDF <= 0.5)
                thisval = 2*ThisCDF;
            else
                thisval = 2*(1-ThisCDF);
            end
        end
        
        function [s,EndingVals,fval,exitflag,output]=EstML(obj,Observations,varargin)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            if numel(varargin)<1
                ParmCodes = obj.DefaultParmCodes;
            else
                ParmCodes = varargin{1};
            end
            RTPFn = @obj.RealsToParms;
            PTRFn = @obj.ParmsToReals;
            ErrFn = @MyErrFunc;
            StartingVals = ParmValues(obj);
            obj.PushAndStopNameBuilding;
            HoldWarn = obj.SkipImpossibleWarn;
            obj.SkipImpossibleWarn = true;  % Do not warn about impossible values when parameter searching.
            [EndingVals,fval,exitflag,output] = fminsearcharb(ErrFn,StartingVals,RTPFn,PTRFn,ParmCodes,obj.SearchOptions);
            obj.SkipImpossibleWarn = HoldWarn;
            obj.ResetParms(EndingVals);
            obj.PopNameBuilding;
            BuildMyName(obj);
            s=obj.StringName;
            function thiserrval=MyErrFunc(X)
                ResetParms(obj,X)
                thiserrval = -LnLikelihood(obj,Observations);
            end
        end

        function [] = DistRename(obj,sNewName)
            % Reset the distribution name to any string sNewName.
            obj.StringName = sNewName;
            obj.NameBuilding = false;  % turn this off so that the name will not be built automatically
        end
        
        function [SE, Cov] = MLSE(obj,X,varargin)  % See DemoMLSE for examples.
            % Use Fisher Information to estimate the standard errors & covariance matrix
            %  of the current parameter estimates with respect to the values in X.
            % This function should only be called after EstML(X) has been used to get ML
            %  estimates for the parameters based on the data in X.
            % This function only returns values for the parameters with ParmCodes=='r';
            %  nan's are returned for the parameters with other ParmCodes (e.g., 'f','i').
            % Notes:
            %   MLSE changes parm values directly, so it may violate parameter constraints (e.g., produce normal sigma below zero).
            %   SEs may have twice as many terms as expected if some solutions have imaginary components.
            
            if numel(varargin)<1
                ParmCodes = obj.DefaultParmCodes;
            else
                ParmCodes = varargin{1};
            end

            NParms = obj.NDistParms;
            OrigParms = obj.ParmValues;
            F0 = LnLikelihood(obj,X);   % Ln likelihood at the current parameters
            RealParms = ParmCodes=='r';
            RealParmAddrs = find(RealParms>0);
            NRealParms = sum(RealParms);
            FI = zeros(NRealParms);  % Allocate space for the k*k Fisher information matrix.
            HoldWarn = obj.SkipImpossibleWarn;
            obj.SkipImpossibleWarn = true;  % Turn off warnings about impossible data values
            for iParm=1:NRealParms
                UpParms = OrigParms;
                iParmAddr = RealParmAddrs(iParm);
                UpParms(iParmAddr) = OrigParms(iParmAddr)+obj.MLSEh;
                obj.ResetParms(UpParms);
                Fup = LnLikelihood(obj,X);
                DownParms = OrigParms;
                DownParms(iParmAddr) = OrigParms(iParmAddr)-obj.MLSEh;
                obj.ResetParms(DownParms);
                Fdown = LnLikelihood(obj,X);
                FI(iParm,iParm) = -(Fup - 2*F0 + Fdown) / obj.MLSEh^2;
                for jParm=iParm+1:NRealParms
                    jParmAddr = RealParmAddrs(jParm);
                    Fup2    = Shift2([iParmAddr jParmAddr],[ obj.MLSEh  obj.MLSEh]);
                    Fdown2  = Shift2([iParmAddr jParmAddr],[-obj.MLSEh -obj.MLSEh]);
                    Fupdown = Shift2([iParmAddr jParmAddr],[ obj.MLSEh -obj.MLSEh]);
                    Fdownup = Shift2([iParmAddr jParmAddr],[-obj.MLSEh  obj.MLSEh]);
                    FI(iParm,jParm) = -(Fup2 + Fdown2 - Fupdown - Fdownup ) / (4*obj.MLSEh^2);
                end
            end
            obj.SkipImpossibleWarn = HoldWarn;
            FI = FI + triu(FI,1)';  % Copy upper triangular into lower triangular.
            % Set up output matrices in case try block fails
            Cov = nan(NParms);
            SE = nan(1,NParms);
            thisrcond = rcond(FI);
            if thisrcond < obj.Smallrcond
                warning(['Nearly singular information matrix (i.e., rcond = ' num2str(thisrcond) ' for ' obj.FamilyName '.  Parameter estimates and information matrix follow:']);
                aOrigParms = OrigParms
                aFI = FI
            end
            % This may generate a warning, because FI may not be invertable.
            CovReal = inv(FI);  % Covariance is the inverse of the information matrix.
            SEReal = sqrt(diag(CovReal))';
            for iParm=1:NRealParms
                iParmAddr = RealParmAddrs(iParm);
                SE(iParmAddr) = SEReal(iParm);
                for jParm=iParm:NRealParms
                    jParmAddr = RealParmAddrs(jParm);
                    Cov(iParmAddr,jParmAddr) = CovReal(iParm,jParm);
                    Cov(jParmAddr,iParmAddr) = CovReal(iParm,jParm);
                end
            end
            obj.ResetParms(OrigParms);
            
            function FNew = Shift2(ParmLoc, ShiftVal)
                % Recompute LnLikelihood of X with shifted values of two parameters.
                % The numbers of the 2 to-be-shifted parameters are in ParmLoc,
                % and the 2 shifts are in ShiftVal.
                NewParms = OrigParms;
                NewParms(ParmLoc(1)) = NewParms(ParmLoc(1)) + ShiftVal(1);
                NewParms(ParmLoc(2)) = NewParms(ParmLoc(2)) + ShiftVal(2);
                obj.ResetParms(NewParms);
                FNew = LnLikelihood(obj,X);
            end
            
        end % function MLSE
        
        function totalerr=MomentError(obj,TargetVals)
            % Ignore moments where TargetVals(I) is nan
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            NToFit = numel(TargetVals);
            totalerr = 0;
            for I=1:NToFit
                if ~isnan(TargetVals(I))  % Ignore moment if target value is nan.
                    switch I
                        case 1
                            MomI = Mean(obj);
                        case 2
                            MomI = Variance(obj);
                        otherwise
                            MomI = CenMoment(obj,I);
                    end
                    totalerr = totalerr + (MomI  - TargetVals(I))^2;
                end % ~isnan
            end
        end
        
        function [s,EndingVals,fval,exitflag,output]=EstMom(obj,TargetVals,varargin)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            if numel(varargin)<1
                ParmCodes = obj.DefaultParmCodes;
            else
                ParmCodes = varargin{1};
            end
            RTPFn = @obj.RealsToParms;
            PTRFn = @obj.ParmsToReals;
            ErrFn = @MyErrFunc;
            StartingVals = ParmValues(obj);
            obj.PushAndStopNameBuilding;
            [EndingVals,fval,exitflag,output] = fminsearcharb(ErrFn,StartingVals,RTPFn,PTRFn,ParmCodes,obj.SearchOptions);
            obj.ResetParms(EndingVals);
            obj.PopNameBuilding;
            BuildMyName(obj);
            s=obj.StringName;
            function thiserrval=MyErrFunc(X)
                ResetParms(obj,X)
                thiserrval = MomentError(obj,TargetVals);
            end
        end
        
        function s = EstMomMS(obj,TargetVals,varargin)
            % A special short-cut moment estimator for when
            % the distribution parameters are defined as MS
            % (e.g., LogNormalMS, RNGammaMS).
            if numel(varargin)<1
                ParmCodes = obj.DefaultParmCodes;
            else
                ParmCodes = varargin{1};
            end
            newmu = ifelse(ParmCodes(1)=='f',obj.mu,TargetVals(1));
            if (ParmCodes(2)=='f')||(numel(TargetVals)==1)
                newsigma = obj.sigma;
            else
                newsigma = sqrt(TargetVals(2));  % Cannot use ifelse in case there is only one TargetVal
            end
            obj.ResetParms([newmu newsigma]);
            s = obj.StringName;
        end

        function ObsMoments = MomentsFromScores(obj,Observations)
            ObsMoments(1) = mean(Observations);
            if obj.NDistParms > 1
                ObsMoments(2) = var(Observations);
            end
            if obj.NDistParms > 2
                ObsMoments(3) = obscenmoment(3,Observations);
            end
            if obj.NDistParms > 3
                ObsMoments(4) = obscenmoment(4,Observations);
            end
        end
        
        function [s,EndingVals,fval,exitflag,output]=EstChiSq(obj,BinUpperBounds,BinProbs,varargin)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            if numel(varargin)<1
                ParmCodes = obj.DefaultParmCodes;
            else
                ParmCodes = varargin{1};
            end
            RTPFn = @obj.RealsToParms;
            PTRFn = @obj.ParmsToReals;
            ErrFn = @MyErrFunc;
            StartingVals = ParmValues(obj);
            obj.PushAndStopNameBuilding;
            [EndingVals,fval,exitflag,output] = fminsearcharb(ErrFn,StartingVals,RTPFn,PTRFn,ParmCodes,obj.SearchOptions);
            obj.ResetParms(EndingVals);
            obj.PopNameBuilding;
            BuildMyName(obj);
            s=obj.StringName;
            function thiserrval=MyErrFunc(X)
                ResetParms(obj,X)
                thiserrval = GofFChiSq(obj,BinUpperBounds,BinProbs);
            end
        end
        
        function totalerr=PercentileError(obj, XValues, TargetCDFs)
            % Compute sum of squared difference between given CDF values
            % and those CDF values associated with the distribution.
            % NWJEFF: Provide additional options:
            %   to measure CDF differences on log(odds) scale
            %   to consider CDFs as fixed and minimize differences on the X scale, as suggested at
            %   https://au.mathworks.com/help/stats/examples/fitting-a-univariate-distribution-using-cumulative-probabilities.html
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            totalerr = 0;
            NToFit = numel(XValues);
            for I = 1:NToFit
                % The next 2 lines provide some sensitivity to size of error at boundaries. }
                if ((XValues(I) < obj.LowerBound) && (TargetCDFs(I) > 0))
                    Err = obj.LowerBound - XValues(I);
                elseif ((XValues(I) > obj.UpperBound) && (TargetCDFs(I) < 1))
                    Err = XValues(I) - obj.UpperBound;
                else
                    PredictedCDF = CDF(obj,XValues(I));
                    % PredictedX = InverseCDF(TargetCDFs(I));
                    % The next 2 lines provide further sensitivity to size of error at boundaries.
                    if  ( (PredictedCDF <= 0) && (TargetCDFs(I) > 0) ) ...
                            || ( (PredictedCDF >= 1) && (TargetCDFs(I) < 1)  )
                        Err = ( XValues(I) - InverseCDF(obj,TargetCDFs(I)) ) * 10;
                    else
                        Err = PredictedCDF - TargetCDFs(I);
                    end
                end
                totalerr = totalerr + Err^2;
            end
        end
        
        function [s,EndingVals,fval,exitflag,output]=EstPctile(obj,XValues,TargetCDFs,varargin)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            if numel(varargin)<1
                ParmCodes = obj.DefaultParmCodes;
            else
                ParmCodes = varargin{1};
            end
            RTPFn = @obj.RealsToParms;
            PTRFn = @obj.ParmsToReals;
            ErrFn = @MyErrFunc;
            StartingVals = ParmValues(obj);
            obj.PushAndStopNameBuilding;
            [EndingVals,fval,exitflag,output] = fminsearcharb(ErrFn,StartingVals,RTPFn,PTRFn,ParmCodes,obj.SearchOptions);
            obj.ResetParms(EndingVals);
            obj.PopNameBuilding;
            BuildMyName(obj);
            s=obj.StringName;
            function thiserrval=MyErrFunc(X)
                ResetParms(obj,X)
                thiserrval = PercentileError(obj,XValues,TargetCDFs);
            end
        end
        
        function [SampleValues, TargetCDF, NPctiles] = PercentilesFromScores(obj,Observations)
            NPctiles = obj.NDistParms;
            if NPctiles > 3
                NPctiles = 3;
            end
            NRands = numel(Observations);
            switch NPctiles
                case 1
                    SampleValues(1) = median(Observations);
                    TargetCDF(1) = 0.5;
                case 2
                    SampleValues(1) = min(Observations);
                    TargetCDF(1) = 0.5 / NRands;
                    SampleValues(2) = max(Observations);
                    TargetCDF(2) = (NRands - 0.5) / NRands;
                case 3
                    SampleValues(1) = min(Observations);
                    TargetCDF(1) = 0.5 / NRands;
                    SampleValues(2) = median(Observations);
                    TargetCDF(2) = 0.5;
                    SampleValues(3) = max(Observations);
                    TargetCDF(3) = (NRands - 0.5) / NRands;
            end
        end

        function [s,EndingVals,fval,exitflag,output]=EstPctBounds(obj,LowerBound,UpperBound,TargetProb,varargin)
            % Adjust parameter(s) so that the desired TargetProb % of the distribution
            % falls between the specified bounds.
            if LowerBound>=UpperBound
                error(GenericError(obj,['Called EstPctBounds with LowerBound = ' num2str(LowerBound) ' and UpperBound = ' num2str(UpperBound)]))
            end
            if (0>=TargetProb) || (TargetProb>=1)
                error(GenericError(obj,['Called EstPctBounds with illegal value of TargetProb = ' num2str(TargetProb)]));
            end
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            if numel(varargin)<1
                ParmCodes = obj.DefaultParmCodes;
            else
                ParmCodes = varargin{1};
            end
            RTPFn = @obj.RealsToParms;
            PTRFn = @obj.ParmsToReals;
            ErrFn = @MyErrFunc;
            StartingVals = ParmValues(obj);
            obj.PushAndStopNameBuilding;
            [EndingVals,fval,exitflag,output] = fminsearcharb(ErrFn,StartingVals,RTPFn,PTRFn,ParmCodes,obj.SearchOptions);
            obj.ResetParms(EndingVals);
            obj.PopNameBuilding;
            BuildMyName(obj);
            s=obj.StringName;
            function thiserrval=MyErrFunc(X)
                ResetParms(obj,X)
                thiserrval = abs(TargetProb - (CDF(obj,UpperBound) - CDF(obj,LowerBound)) );
            end
        end
        
        function [s,EndingVals,fval,exitflag,output]=EstProbitYNML(obj,Constants,NTrials,NGreater,varargin)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            if numel(varargin)<1
                ParmCodes = obj.DefaultParmCodes;
            else
                ParmCodes = varargin{1};
            end
            RTPFn = @obj.RealsToParms;
            PTRFn = @obj.ParmsToReals;
            ErrFn = @MyErrFunc;
            StartingVals = ParmValues(obj);
            obj.PushAndStopNameBuilding;
            [EndingVals,fval,exitflag,output] = fminsearcharb(ErrFn,StartingVals,RTPFn,PTRFn,ParmCodes,obj.SearchOptions);
            obj.ResetParms(EndingVals);
            obj.PopNameBuilding;
            BuildMyName(obj);
            s=obj.StringName;
            function thiserrval=MyErrFunc(X)
                ResetParms(obj,X)
                thiserrval = -YNProbitLnLikelihood(obj,Constants,NTrials,NGreater);
            end
        end
        
        function [s,EndingVals,fval,exitflag,output]=EstProbitYNChiSq(obj,Constants,NTrials,NGreater,varargin)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            if numel(varargin)<1
                ParmCodes = obj.DefaultParmCodes;
            else
                ParmCodes = varargin{1};
            end
            RTPFn = @obj.RealsToParms;
            PTRFn = @obj.ParmsToReals;
            ErrFn = @MyErrFunc;
            StartingVals = ParmValues(obj);
            obj.PushAndStopNameBuilding;
            [EndingVals,fval,exitflag,output] = fminsearcharb(ErrFn,StartingVals,RTPFn,PTRFn,ParmCodes,obj.SearchOptions);
            obj.ResetParms(EndingVals);
            obj.PopNameBuilding;
            BuildMyName(obj);
            s=obj.StringName;
            function thiserrval=MyErrFunc(X)
                ResetParms(obj,X)
                thiserrval = YNProbitChiSq(obj,Constants,NTrials,NGreater);
            end
        end
        
        function [s,EndingVals,fval,exitflag,output]=EstProbitmAFCML(obj,M,Constants,NTrials,NGreater,varargin)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            if numel(varargin)<1
                ParmCodes = obj.DefaultParmCodes;
            else
                ParmCodes = varargin{1};
            end
            RTPFn = @obj.RealsToParms;
            PTRFn = @obj.ParmsToReals;
            ErrFn = @MyErrFunc;
            StartingVals = ParmValues(obj);
            obj.PushAndStopNameBuilding;
            [EndingVals,fval,exitflag,output] = fminsearcharb(ErrFn,StartingVals,RTPFn,PTRFn,ParmCodes,obj.SearchOptions);
            obj.ResetParms(EndingVals);
            obj.PopNameBuilding;
            BuildMyName(obj);
            s=obj.StringName;
            function thiserrval=MyErrFunc(X)
                ResetParms(obj,X)
                thiserrval = -mAFCProbitLnLikelihood(obj,M,Constants,NTrials,NGreater);
            end
        end
        
        function [s,EndingVals,fval,exitflag,output]=EstProbitmAFCChiSq(obj,M,Constants,NTrials,NGreater,varargin)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            if numel(varargin)<1
                ParmCodes = obj.DefaultParmCodes;
            else
                ParmCodes = varargin{1};
            end
            RTPFn = @obj.RealsToParms;
            PTRFn = @obj.ParmsToReals;
            ErrFn = @MyErrFunc;
            StartingVals = ParmValues(obj);
            obj.PushAndStopNameBuilding;
            [EndingVals,fval,exitflag,output] = fminsearcharb(ErrFn,StartingVals,RTPFn,PTRFn,ParmCodes,obj.SearchOptions);
            obj.ResetParms(EndingVals);
            obj.PopNameBuilding;
            BuildMyName(obj);
            s=obj.StringName;
            function thiserrval=MyErrFunc(X)
                ResetParms(obj,X)
                thiserrval = mAFCProbitChiSq(obj,M,Constants,NTrials,NGreater);
            end
        end
        
        function PlotDens(obj,varargin)  % NWJEFF: More work needed:
            % Extend to bounds if the tails are not too stretched.
            % Parameters to specify X range or CDF(X) range
            % Parameters to select out only PDF or CDF or Hazard
            % Nice numbers for PDF ticks
            nvarargin = numel(varargin);
            nticks = 5;
            x = XsToPlot(obj);
            pdfy = PDF(obj,x);
            cdfy = CDF(obj,x);
            figure;
            [AX,H1,H2] = plotyy(x,pdfy,x,cdfy);
            ylim(AX(2),[-0.02 1.02]);
            xlabel('X');
            title(obj.StringName)
            set(get(AX(1),'Ylabel'),'String','PDF(X)');
            set(get(AX(2),'Ylabel'),'String','CDF(X)');
            minpdfy = 0;
            maxpdfy = max(pdfy);
            set(AX(1),'YTick',minpdfy:(maxpdfy-minpdfy)/nticks:maxpdfy);
            set(AX(2),'YTick',0:0.2:1);
            if obj.DistType == 'd'
                set(H1,'linestyle','none','marker','o');
                set(H2,'linestyle','none','marker','*');
            end
        end
        
        function BinProb=FindBinProbs(obj, BinMax)
            % This function creates an output vector of length NBins giving the probability in each bin.
            % The bottom of the first bin is implicitly obj.LowerBound, and the top of bin I is BinMax(I).
            % BinMax(NBins) always equals obj.UpperBound.
            BinProb = CDF(obj,BinMax);
            for iBin=numel(BinMax):-1:2
                BinProb(iBin) = BinProb(iBin) - BinProb(iBin-1);
            end
        end
        
        % *** Spline approximation starts here
        
        function UseSplinePDFOn(obj,NBinsOrListOfX)
            obj.SplinePDFsXSpec = NBinsOrListOfX;
            if numel(obj.SplinePDFsXSpec) == 1
                StepSize = (obj.UpperBound - obj.LowerBound) / obj.SplinePDFsXSpec;
                obj.SplinePDFsXs = obj.LowerBound+StepSize:StepSize:obj.UpperBound-StepSize;
            else
                obj.SplinePDFsXs = obj.SplinePDFsXSpec;
            end
            obj.UseSplinePDF = false;
            obj.SplinePDFs = PDF(obj,obj.SplinePDFsXs);
            obj.PDFSplineInfo = spline(obj.SplinePDFsXs,[0 obj.SplinePDFs 0]);  % Include end 0's to guarantee flatness at edges.
            obj.UseSplinePDF = true;
            obj.HaveSplinePDFs = true;
        end
        
        function UseSplinePDFOff(obj)
            obj.UseSplinePDF = false;
            obj.HaveSplinePDFs = false;
        end
        
        function thispdf=GetSplinePDF(obj,X)
            if ~obj.HaveSplinePDFs
                UseSplinePDFOn(obj,obj.SplinePDFsXSpec)
            end
            thispdf=zeros(size(X));
            InBounds = (X>=obj.LowerBound) & (X<=obj.UpperBound);
            thispdf(InBounds) = ppval(obj.PDFSplineInfo,X(InBounds));
            thispdf(thispdf<0) = 0;
        end
        
        function UseSplineCDFOn(obj,NBinsOrListOfX)
            obj.SplineCDFsXSpec = NBinsOrListOfX;
            if numel(obj.SplineCDFsXSpec) == 1
                StepSize = (obj.UpperBound - obj.LowerBound) / obj.SplineCDFsXSpec;
                obj.SplineCDFsXs = obj.LowerBound+StepSize:StepSize:obj.UpperBound-StepSize;
            else
                obj.SplineCDFsXs = obj.SplineCDFsXSpec;
            end
            obj.UseSplineCDF = false;
            obj.SplineCDFs = CDF(obj,obj.SplineCDFsXs);
            obj.CDFSplineInfo = spline([obj.LowerBound obj.SplineCDFsXs obj.UpperBound],[0 obj.SplineCDFs 1]);  % The 0/1 at the ends guarantee flatness at ends
            obj.UseSplineCDF = true;
            obj.HaveSplineCDFs = true;
        end
        
        function UseSplineCDFOff(obj)
            obj.UseSplineCDF = false;
            obj.HaveSplineCDFs = false;
        end
        
        function thiscdf=GetSplineCDF(obj,X)
            if ~obj.HaveSplineCDFs
                UseSplineCDFOn(obj,obj.SplineCDFsXSpec)
            end
            thiscdf=zeros(size(X));
            InBounds = (X>=obj.LowerBound) & (X<=obj.UpperBound);
            thiscdf(X>obj.UpperBound) = 1;
            thiscdf(InBounds) = ppval(obj.CDFSplineInfo,X(InBounds));
            thiscdf(thiscdf<0) = 0;
            thiscdf(thiscdf>1) = 1;
        end
        
        function [thisval, InBounds, Done] = MaybeSplineInvCDF(obj,P)
            if ~obj.Initialized
                error(UninitializedError(obj));
            end
            assert(sum(P<0)+sum(P>1)==0,'Error: All Ps must be between 0 & 1');
            thisval=zeros(size(P));
            InBounds = true(size(P));
            if obj.UseSplineInvCDF
                thisval = obj.GetSplineInvCDF(P);
                Done = true;
            else
                Done = false;
            end
        end
        
        function UseSplineInvCDFOn(obj,NBinsOrListOfX)
            obj.SplineInvCDFsXSpec = NBinsOrListOfX;
            if numel(obj.SplineInvCDFsXSpec) == 1
                obj.SplineInvCDFsPs = (1:2:2*NBinsOrListOfX-1) / (2*NBinsOrListOfX);
            else
                obj.SplineInvCDFsPs = obj.SplineInvCDFsXSpec;
            end
            obj.UseSplineInvCDF = false;
            obj.SplineInvCDFs = InverseCDF(obj,obj.SplineInvCDFsPs);
            obj.InvCDFSplineInfo = spline(obj.SplineInvCDFsPs,[obj.SplineInvCDFs]);  % The 0/1 at the ends guarantee flatness at ends
            obj.UseSplineInvCDF = true;
            obj.HaveSplineInvCDFs = true;
        end
        
        function UseSplineInvCDFOff(obj)
            obj.UseSplineInvCDF = false;
            obj.HaveSplineInvCDFs = false;
        end
        
        function thisInvCDF=GetSplineInvCDF(obj,P)
            if ~obj.HaveSplineInvCDFs
                UseSplineInvCDFOn(obj,obj.SplineInvCDFsXSpec)
            end
            thisInvCDF=zeros(size(P));
            assert(sum(P<0)+sum(P>1)==0,'Error: All Ps must be between 0 & 1');
            thisInvCDF = ppval(obj.InvCDFSplineInfo,P);
        end
        
        function [BinMax,BinProb]=MakeBinSet(obj,MinPr)
            switch obj.DistType
                case 'c'
                    [BinMax,BinProb] = obj.MakeBinSetC(MinPr);
                case 'd'
                    [BinMax,BinProb] = obj.MakeBinSetD(MinPr);
                otherwise
                    ME = MException('dGeneric:MakeBinSet', ...
                        ['Unsupported distribution type: ' obj.DistType]);
                    throw(ME);
            end
        end
    
    end  % methods

end  % class dGeneric

